  
![](https://mmbiz.qlogo.cn/mmbiz_png/qX2ED6UwyKG3kbKnZpeFkiafsw1AqwqcJ6Yk0icQQRulaUV6YWMwiajuYUweXbbQaPYS6UdjaqOA5FvHSQoibeGRpQ/0?wx_fmt=png)
<center>▲谷歌和C++有着某种天然的联系</center>

说起“谷哥”的厨艺，天下人恐怕很少说它煮出来的菜不美味的。

评价一位武学大家造诣如何，那么只消看看其门下的弟子，在江湖上是否有头有脸有传说即可。

张三丰有武当七侠在外步道，称雄江湖。近年热门的一代宗师叶问，其门下出过一位天下闻名的李小龙。虽然说状元学生不一定有个状元师傅，但是我们透过李小龙荧屏上精彩干净漂亮的动作，大致可以想见叶问当有的风采。

同理，没有进入google大门的人们，只消看看互联网的几个扬名在外的门派，正在出名或不出名的门派的掌门人都是谁，那么“谷哥”的厨艺如何，大概不用脑子也能想得到。

百度那边之前请了几个知名的大厨，(我觉得技术人称为师傅，是一个足够有分量的称呼了，假如技术算是一门手艺的话。)，不少师出google，比如范丽，王劲，吕厚昌。腾讯搜搜当年的吴军，朱会灿，也都在google里炒得一手好菜。云壤创始时期的几个掌厨人，也都是师出google，比如互联网江湖常常提起的刘骏，孙峥，陈利人（待字闺中公众号的作者）。至于创新工场的掌门人李开复，兰亭集势的掌门人郭去疾，小米创业初期的一些元老，无不是google系的。当然，我最近所在的公司出门问问，前年拿到了谷歌的投资，公司的CEO和CTO均系出谷歌。

拉拉扯扯那么多，可能有些人不以为然，老大们可能早都金盘洗手，不写代码了。这里的掌厨更多的是当管理，做老大，似乎和写代码意义上的掌厨风马牛不相及。

其实不然。就我所知，google系的人当了老大后，很多还喜欢舞文弄墨，偶尔炒炒几个精美小菜，或者亲自制定个菜谱，让底下人照着口味炒出来。比如我看吴军早先微博上声称，他还偶尔写写代码，做做code review，当个美食家，品鉴师。据江湖朋友说，朱会灿更是宝刀未老，经常对下面的厨师们端上的菜品，指点江山，激扬文字。出门问问的CTO雷欣，当前也经常给团队做code review，如有闲暇，也会写一些代码。

我接触的几个云壤的主厨们，当年创业的时候，仍然对主厨乐此不疲，公司重要的菜品，都是他们分别烹煮出来的。从用料到火候，到菜色的把握，劲道的讲究，都样样兼顾。

就此而言，google系的存在，对我们这帮后辈们来说可谓压力山大，只要他们不退役，我们就似乎只能高山仰止的份，而无出头之日了。当然，我们也应该认识到，能够和他们一起烹制一道人间美食，也是莫大的荣幸。

下面，我们就来一一品鉴下“谷哥”的大厨们奉献给天下嘴馋的程序猿们的饕餮大餐。这里挑选的标准是，整个项目都是google开发的，或者是google主导的。同时，挑选的时候，还去除了庞大的项目，比如Chromium，只挑选那些普天之下的程序猿都可以在自己的项目中使用上的项目。

另外需要说明的是，这里只是对美食的风味进行外行的品鉴，并对美食的功效进行蜻蜓点水式的普及，至于这些美味佳肴是如何烹制出来的，使用到了什么高级食材，烹煮的火候如何，则有待方家他日出来指点了。

### Gflags

该库的主要好处是，可以通过一个函数搞定所有的命令行参数解析。想想很多开源项目，几乎要使用上百行甚至几百行代码，用于解析命令行参数，main函数冗长到近乎难以卒读。

有了gflags,你只需要调用  ParseCommandLineFlags  函数，就完成了所有的复杂的命令行解析工作。同时，该库至少还有以下几个好处：

-   引入该模块，使用到该库的所有模块，都拥有了同样的命令行参数风格。
-   命令行参数的定义与使用，不再需要集中到main函数对应的文件，而是根据模块化设计，分散到各个文件中。
-   命令行参数的风格统一，都是—version, --help, --helpshort之类的风格，
-   命令行的定义与使用绑定在一起，比如

```cpp
    DEFINE_string(log_filename, "log.txt", "filename for log file");
```
-   使用--help查看的时候，可以显示默认值，参数的意义。
-   可以使用内置的--help查看某个binary使用到的所有flags,以及其对应的意义。
-   可以使用flagfile，用来管理线上模块复杂的命令行参数。
-   结合blade/bazel等构建工具，设置可以提供默认的--version等命令，用于查看Binary相关信息，比如谁编译的，代码的版本信息，编译的主机名，编译时间，编译的相关环境信息(操作系统，gcc版本等)。而这一切信息，都是构建工具帮你自动收集并绑定到Binary内部的。

### Glog
一般比较大的软件，都会有日志模块，以打印一些信息，用于调试，或者跟踪分析等。很多程序员可能都写过自己的日志库，或者是使用过开源的日志库，

比如较为著名的Log4cplus，java的 log4j 。不过个人使用过的最方便简洁的日志库（C++），还是google出品的。

其有以下几个特点。
-   流式风格，输出日志便捷，比如
```cpp    
    LOG(INFO) << "thread started, tid:" << tid();
```    
-   默认输出到标准输出，对很多小工具而言，不需要指定日志文件名，不需要进行任何初始化操作。
-   如果要指定日志文件，可以调用 InitGoogleLogging 函数进行设置。
-   提供了不同的log等级，包括INFO，WARNING，ERROR，FATAL等。
-   提供了丰富的宏，比如DLOG, LOG_IF，CHECK，DCHECK。
-   提供了VLOG功能，程序启动的时候，随着需求不同，可以开启不同的级别，而所需要的工作仅仅是在命令行中指定 --v=level。
-   日志信息足够丰富，包含输出时间，源文件名，代码行号，日志等级以及用户输出的具体信息等。

### Gtest

著名的单元测试框架有很多，比如CppUnit，boost的单元测试框架等。不过还是gtest有其过人的优点：
1，简洁到极致。比如你要测试以下函数

```cpp
int Add(int a, int b) { 
  return a + b;
}
```
你只需要编写简单的几行代码即可：
```cpp
TEST(AddTest, SilmpleTest) {
 EXPECT_EQ(Add(1, 2), 3);
 EXPECT_EQ(Add(-1, 2), 1);
}
```
  
2，提供了丰富的宏。gtest提供了非常多的宏，比如EXPECT_EQ，EXPECTFALSE，EXPECT_GT，ASSERT_DEATH等。

3，可以继承Test类，然后使用TEST_F宏，这样就可以在一组测试用例中共享很多数据和操作了。

4，使用简单：
你最好使用以下代码，就可以执行相应的单元测试。
```cpp
int main(int argc, char** argv{
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();  
}
```

如果结合Blade之间的高级构建工具，则编写单元测试会更加方便。Blade定义了cc_test, 其内部会自动连接一个libgtest_main.a,你连main函数都不需要自己实现了。

同时，结合blade和下面要介绍的Gperftools,还可以在运行单元测试的时候，自动检测内存泄露等。

5，输出信息友好。Gtest输出的信息是彩色的，按照test case输出，并会输出各个测试用例的执行时间，提供多样的测试报告。

### Gmock

该库用户实现桩代码，与gtest结合，能更好地实现对一些代码的测试。

比如测试网络服务相关代码，由于网络存在不稳定性，直接运行可能会导致单元测试不稳定，时而成功时而失败。

Gmock还可以用在一些复杂模块的协同开发。比如module B 依赖module A，在开发B的时候，要进行单元测试，但是A虽然接口已经实现了，但是功能还没有实现。这时候就可以你一个MockB, 用于测试A，保证A和B可以更好地同时进行开发。

### Gperftools

这个是google在程序性能方面的利器。有以下用处
-   内含tcmalloc,内存管理方便更加强大。本人写过的某个模块，不链接该库与链接该库的内存比大约是10:7 ,简单链接该库，内存占用明显降低。比自己实现代码花大力气优化带来的好处还大。
-   提供了内存泄露检测功能。结合其提供的pprof工具，可以非常方便地定义内存泄露的代码。
    
      
    
-   提供了HEAPPROFILE功能，用于检测程序中哪些代码最为消耗内存，用于定位改进内存使用。
    
      
    
-   提供了CPUPROFILE功能，用于性能调优方面，效果极佳。腾讯台风系统实现的google protobuf RPC框架poppy，便使用它提供了在线profile功能。
    

  

### Protobuf

  

Google的序列化与反序列化功能，类似的有facebook出品的thrift. 国内公司，使用thrift的团队应该不在少数，不过protobuf至少有以下几个强项：

  

-   提供了TextFormat，这个与thrift的string表示不可等同而观，thrift的string是残缺的，因此无法反序列化，而google protofbuf的TextFormat则是完整的，可以反序列化。因此protobuf天然适合作为配置文件。一个复杂的配置，只要表示为protobuf的text format，可读性好，人工可直接编辑。同时，简单几行代码即可实现反序列化，后续读取配置项，简单方便。
    
      
    
    值得一提的是，甚至有直接使用windows窗口、浏览器表单等，直接配置protobuf配置项的开源项目。
    
      
    
-   protobuf设置了反射功能。这个使得实现不同的format非常方便，比如实现从Json转protobuf，从Protobuf转json都非常方便。
    
    反射的设计，使得poppy之类RPC能够提供比thrift 内置的RPC更为强大，更为酷的功能。
    
      
    
-   protobuf可以实现对未知字段的透明传递，比如有几个模块使用了protobuf Data进行传输，a-->b-->c-->d, 如果A在Data中添加某个字段，d模块需要使用该字段，如果使用thrift，则四个模块全部需要重新编译部署上线，而使用protobuf的话，则只需要更新上线模块a和d。
    
      
    
-   thrift 的RPC，数据包没有id的概念，同一个RPC调用多次，可能这次的返回数据，会是上次调用返回的数据。因为使用者需要对超时等问题进行复杂的处理。
    

### Leveldb

  

Leveldb是google开源出来的sstable实现，其性能表现优越，具体可以参考其benchmark记录。如果需要实现一个简单的sstable server, 则可以考虑使用leveldb,某些小型规模的数据，也可以考虑直接使用leveldb进行存储。

  

### Snappy

  

压缩库有很多，著名的比如zlib, lzo等，snappy则是google出品的在读写性能与压缩比等各个指标间取得很好的平衡的压缩库。Google内部的BigTable，应该就是使用snappy进行压缩的。Snappy开源库中内置了benchmark程序，读者朋友要是有兴趣，可以自己跑跑与其它压缩库的对比。

  

### Re2

  

正则表达式是大家经常使用的功能。在匹配url,比如文本内容等场合，都需要使用到正则表达式。除了Linux系统内置的正则库外，知名的还有boost的正则库等。

  

既然有了这么多的开源库，google为什么要实现自己的正则库呢？个人猜测，可能是搜索等相关业务，使用到正则的频繁较高，且正则表达式的规模不小，对其性能有较高的要求。不错，re2的强势，正是在于其超强的性能。Re2通过对正则语法的适当裁剪，专注在高性能。

  

关注性能的朋友，不妨试试re2这个开源项目。

  

不过re2也有几个缺点：

1.  支持的正则语法有所限制，比如回溯功能就不支持
    
2.  re2不支持gbk等编码。
    

### **结语**

想必有经验的工程师，应该都有几个得心应手的开源项目，上面介绍的几个开源项目，便都是“谷哥”这位大厨掌勺亲自为广大程序猿提供的免费大餐。

我很喜欢这些大餐，因为他们色香味俱佳，吃多了，对健康很有好处。不知道没有尝试过的朋友们，是不是已经垂涎三尺了呢？

​
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTk5OTczMTk5N119
-->