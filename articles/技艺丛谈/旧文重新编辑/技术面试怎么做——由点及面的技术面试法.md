在上篇文章《[C++ Singleton 发展史 | 面向对象的世界里，写错单例模式，你并不孤单](http://mp.weixin.qq.com/s?__biz=MzI3NzE1NDcyNQ==&mid=2247484352&idx=1&sn=93183add638fa03a2c38b4ddf40671db&chksm=eb6bdd0adc1c541c523deb6ac54aca3c16f271d249c39aef1fc0d0b007a038ed0c7acb4e54e7&scene=21#wechat_redirect)》中，我们邀请丁辉给我们分享了 C++ 中单例设计模式的发展，通过史海钩沉，探寻到了 C++ 设计模式的不同实现。我自己面试别人也经常使用 singleton 设计模式作为考题，不是因为要装逼，而是**这个设计模式大家平时都会使用到，并且多多少少都听过**。而考察其他设计模式，可能就需要费一番口舌，介绍该设计模式是什么意思，有什么使用场景等。

而在我自己的面试生涯中，我面试过至少一百人 singleton 设计模式，遇到的问题也至少有一百种，写法千奇百怪，错法更是五花百门。我也自己也曾经被问过多次 singleton 设计模式，**虽也是深受其害，却也从中学到了很多知识点**。**这里简单分享下我遇到的那些常见的错误，对 C++ 语言的众多误解和概念模糊，并顺带探讨一种由点及面的面试方法。**

记得我刚毕业的时候，去面试一家公司，他们的技术总监让我在黑板上写一个单例设计模式。当时我正通读过四人帮的《设计模式》，心中窃喜：这不是正中本大侠下怀么？本大侠有备而来，这下真是有备无患啊，哈哈哈。  

我快速写了一个实现，代码大致如下。大家可以思考一会，以下代码有哪些问题，作为面试官，又可以继续问哪些问题？
```cpp
1.  `// singleton.h`
2.  `class  Singleton  {`
    
3.   `public:`
    
4.   `static  Singleton*  Instance();`
    

6.   `private:`
    
7.   `Singleton();`
    
8.   `static  Singleton* instance_;`
    
9.  `};  
    `
    
10.  

12.  `// singleton.cc`
    
13.  `Singleton*  Singleton::instance_ = NULL;`
    

15.  `Singleton::Singleton()  {}`
    

17.  `Singleton*  Singleton::Instance()  {`
    
18.   `if  (instance_ == NULL)  {`
    
19.   `instance_ =  new  Singleton;`
    
20.   `}`
    
21.   `return instance_;`
    
22.  `}`
    
```
写代码的时候，面试官说他有事，让我先自己在黑板上慢慢写，便临时出去了。我写了不到五分钟，等了十几分钟，面试官还没出现，只要走出会议室，让前台帮我找面试官回来。

面试官回来了，简单看了下代码，什么也没问，只是告诉我：“行，我知道你的水平了，先这样吧。”我问有什么问题么，面试官也没搭我的话，只是说知道我的水平了，并说他在微软面试过很多人，不少人写出来的单例比我好一些。当时我真是一脸懵逼。光不明不白地和我说“面试过的人里比你写得好的有不少”，更是让我心中不服气。NND，我这可是从伟大的四人帮的正宗的《设计模式》里原样复制过来的啊。

  

不服气也没用。回去以后，各种参阅书籍，继续钻研单例设计模式。人总不能在同一个地方摔倒，还摔得莫名其妙，无从爬起吧？**单例这玩意，你哪怕单身二十年，也尝不完单例的一百种滋味。**后来我面试别人的时候，也渐渐喜欢上面试这个最广为人知的设计模式，每次面试，也稍微求变，尝试通过考察设计模式，到考察 C++ 语言知识，到考察编译器和操作系统等。而这其中的实践，也慢慢让我形成了**由点及面的面试法**。以下通过 singleton 这个面试题来慢慢阐述这个面试法，**希望对应聘者和经验不多的面试官有所帮助。**

  

为了方便，我在以下设计两个角色。一个是面试官，一个是应聘者。

  

**场景一**

**![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)**

下面来了一个初涉江湖的菜鸟选手。

**面试官**：请问你熟悉设计模式么？

应聘者：不太熟悉。大概知道几个常用的，比如抽象工厂，工厂方法，单例模式等。

**面试官**：那能不能简单写一下单例模式

应聘者：可以（然后应聘者开始写代码）

  

1.  `class A {`
    
2.   `public:`
    
3.   `A*  GetInstance();`
    
4.   `private:`
    
5.   `static A* a_;`
    
6.  `}  
    `
    
7.  

9.  `A* A::GetInstance()  {`
    
10.   `if  (a_ == NULL)  {`
    
11.   `a_ =  new A;`
    
12.   `}`
    
13.   `return a_;`
    
14.  `}`
    

  

**面试官**：请问这里为什么返回指针，返回引用可以么？

应聘者：xxx（这里读者可以自行发挥，不熟悉的，可以自行谷歌）

**面试官**：再问个问题，为什么成员变量是 static 的？

应聘者：xxx，不是 static 的好像也可以，我想想。

**面试官**：static 和 非 static 有什么区别么？

应聘者：xxx

**面试官**：static 关键字有几种作用？**（面试官开始问 C/C++ 关键字的掌握程度）**

应聘者：xxx

**面试官**：好，那再问一下，你这里 GetInstance 怎么才可以调用？需要生成对象，使用对象来调用它么？还是直接使用类就可以调用？

应聘者：当然需要对象啊，

**面试官**：那既然是对象，怎么构造出这个对象？

应聘者：调用 GetInstance 方法啊。（于是开始了鸡生蛋，蛋生鸡的讨论）  

……

  

**场景二**

![](https://mmbiz.qpic.cn/mmbiz_jpg/qX2ED6UwyKGBOMQWFvEBzaxWLlJcs8796Urqw8qFTOSGTzMSiaW09T9aJPMnNIWZXZNnFFCdgTDHlkqHsZDYqfQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

下面来了个稍微溜一些的应聘者。

  

**面试官**：你熟悉单例设计模式么？

应聘者：还可以

**面试官**：那你觉得单例设计模式在什么场景使用比较频繁？

应聘者：xxx

**面试官**：假如要在 C 语言中 做类似 Singleton 模式的事情，应该怎么做？**（考察 C 语言 和 C++ 语言的区别和联系）**

应聘者：类似全局变量吧。xxx

**面试官**：行吧，那我们言归正传，要不你在黑板上简单实现一下 C++ 的做法吧。

应聘者：好的，那我写一下。

  

1.  `// singleton.h`
    
2.  `class A {`
    
3.   `public:`
    
4.   `static A*  GetInstance();`
    
5.   `private:`
    
6.   `static A* a_;`
    
7.  `}  
    `
    
8.  

10.  `//  singleton.cc`
    
11.  `static A* A::a_ = NULL;`
    
12.  `static A* A::GetInstance()  {`
    
13.   `if  (a_ == NULL)  {`
    
14.   `a_ =  new A;`
    
15.   `}`
    
16.   `return a_;`
    
17.  `}`
    

  

**面试官**：请问这里的 GetInstance 方法，为什么需要加一个 static ？

应聘者：因为不是 static 的话，没法访问到 static 成员变量呀。

**面试官**：你确定不是 static 的方法，无法访问 static 成员变量么？**（对候选人看似很确定的知识，故意反问一两次，可以考察候选人对某个知识是否真正掌握原理，记忆是否模糊）**

应聘者：我再想想。（陷入沉思……），嗯，我确定。

**面试官**：那 static 和 非 static 方法，在函数调用时，参数调用上有什么不一样的？

应聘者：非 static 的函数，一般都会带有一个 this 指针吧。**（可以延伸考察 this 指针，考察 C++ 对象内存模型，函数调用的参数顺序等）**

**面试官**：那请问你这里的实现，是真正的单例么？我能不能直接构造出来？

应聘者：哦，我看看，哦，对，这里忘了把构造函数设置为 private 了。

**面试官**：你这里不是没有实现构造函数么？可以使用构造函数构造出来对象么？

应聘者：可以的，编译器会生成一个构造函数。

**面试官**：是么。那对 C++ 而言，编译器会自动帮你生成哪些函数？除了无参构造函数。

应聘者：我想想，应该还有吧，比如拷贝构造什么的。

**面试官**：那这里拷贝构造等需要做处理么？

应聘者：不需要吧，只要我加上无参构造的话，编译器不会自动生成别的函数。

……

  

**场景三**

![](https://mmbiz.qpic.cn/mmbiz_jpg/qX2ED6UwyKGBOMQWFvEBzaxWLlJcs8796Urqw8qFTOSGTzMSiaW09T9aJPMnNIWZXZNnFFCdgTDHlkqHsZDYqfQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

下面来了位经验更丰富的。

**面试官**：熟悉设计模式么？

应聘者：嗯，一二十种大概都看过，看过四人帮的书。**（这时候也可以延伸开问，C++ 都有哪些名著，候选人看过哪些，有什么收获等——阅读好书是一个非常好的习惯）**

**面试官**：你平时使用过哪些设计模式？

应聘者：单例啊，比如在资源加载的时候，一般会使用 singleton，防止多个实例占用过多的内存，消耗过多的时间等。还有工厂方法之类的。C++ STL 里的迭代器，也算是一种设计模式吧。 C# 语言里经常有代理委托模式等。……

**面试官**：行吧，要不你简单写下 singlenton 设计模式？

应聘者：可以。

  

1.  `// singleton.h`
    
2.  `class  Singleton  {`
    
3.   `public:`
    
4.   `static  Singleton*  Instance();`
    

6.   `private:`
    
7.   `Singleton();`
    
8.   `static  Singleton* instance_;`
    
9.  `};  
    `
    
10.  

12.  `// singleton.cc`
    
13.  `Singleton*  Singleton::instance_ = NULL;`
    

15.  `Singleton::Singleton()  {}`
    

17.  `Singleton*  Singleton::Instance()  {`
    
18.   `if  (instance_ == NULL)  {`
    
19.   `instance_ =  new  Singleton;`
    
20.   `}`
    
21.   `return instance_;`
    
22.  `}`
    

  

**面试官**：写得挺快的。我有个疑问，这里构造函数是 private 的，那么析构函数需要 private 么？

应聘者：我想想，之前倒是没想过析构函数的问题。……应该不需要吧，反正也没人需要 delete 这个对象。  

**面试官**：是么？那么析构函数需要实现么？还是可以只声明，不实现？

应聘者：我想想。……，xxx

**面试官**：我们一般编程有个原则，就是保持配对，比如 malloc 和 free, new 和 delete 要配对，否则就会存在内存泄漏。你感觉这里会出现内存泄漏么？

应聘者：应该是会的。不过这个 singleton 整个进程只有一个，泄漏了也没什么影响吧，进程退出的时候，内存会被释放。

**面试官**：那假如有个内存泄漏工具，在跑单元测试的时候，发现这个实现存在内存泄漏，该怎么解决？

应聘者：xxx

**面试官**：你有内存泄漏检测的经验么？**（面试官开始考察内存方面的问题）**

应聘者：xxx

**面试官**：一般有哪些内存方面的 bad practice 会引起内存方面的问题？

应聘者：xxx

**面试官**：有什么内存泄漏检测的工具或者开源项目么？

应聘者：我知道有个谷歌的工具，名字叫什么我忘了。好像 GNU 也有类似的工具。

**面试官**：你知道它们的大概原理么？如果要自己实现一个粗糙的类似工具，用于检测内存泄漏，你感觉可以怎么入手？**（面试官开始问开源项目的底层实现机制）**

应聘者：xxx

  

**场景四**

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

下面来了一位更资深的 C++ 工程师，信心满满。

**面试官**：单例设计模式你应该比较熟悉吧？

应聘者：嗯，还可以。

**面试官**：好，那我就不介绍了，你简单帮写一个这个模式。

应聘者：好。（不到五分钟，写完了以下代码）

  

1.  `// singleton.h`
    
2.  `class  Singleton  {`
    
3.   `public:`
    
4.   `static  Singleton*  Instance();`
    

6.   `private:`
    
7.   `Singleton();`
    
8.   `static  Singleton* instance_;`
    
9.   `DISALLOW_COPY_AND_ASSIGN(Singleton);`
    
10.  `};  
    `
    
11.  

13.  `// singleton.cc`
    
14.  `Singleton*  Singleton::instance_ = NULL;`
    

16.  `Singleton::Singleton()  {}`
    

18.  `Singleton*  Singleton::Instance()  {`
    
19.   `if  (instance_ == NULL)  {`
    
20.   `instance_ =  new  Singleton;`
    
21.   `}`
    
22.   `return instance_;`
    
23.  `}`
    

**面试官**：这里的 DISALLOW_COPY_AND_ASSIGN 是什么意思？

应聘者：它是一个宏，展开后就是拷贝构造和赋值构造。

**面试官**：你能简单实现一下这个宏么？

应聘者：可以。（候选人快速写了以下代码）

1.  `#define DISALLOW_COPY_AND_ASSIGN(TypeName) \`
    
2.   `TypeName(const  TypeName&); \`
    
3.   `TypeName&  operator=(const  TypeName&)`
    

**面试官**：这里要 const 和引用么？不加 const 或者不是引用可以么？

应聘者：xxx

**面试官**：你确定么？

应聘者：确定。

**面试官**：这里宏的最后没有分号，为什么？是有分号好，还是没有分号好？

应聘者：xxx

**面试官**：你代码里，instance_ 的初始化，放在 singleton.cc 文件里，为什么？能不能放在 singleton.h 文件里完成初始化？如果不可以，有什么问题？

应聘者：xxx

**面试官**：有个小问题问你下，如果要线程安全，应该怎么做？

应聘者：加个锁吧。在 Instance 函数的入口，加一个锁。

**面试官**：锁加在这里是对的么？你再想想？

应聘者：应该是对的吧。

**面试官**：那有没有性能更好的实现？

应聘者：（沉思了一两分钟）……暂时没有想到。

**面试官**：那我请问下，你这里 new 出来的对象，是否需要释放内存？

应聘者：哦，对，看起来是需要释放的。否则可能内存泄漏等工具会检测出来。

**面试官**：编程实践中，new 和 delete 不匹配等问题，有什么好的实践可以规避下？**（可以往内存管理，缓冲区溢出，智能指针等延伸）**

应聘者：智能指针之类的吧，unique_ptr, shared_ptr 等。

**面试官**：（问了一些智能指针的问题后），好，那我们再看看，这里的内存应该怎么来释放？

应聘者：可以考虑搞一个和 Instance( ) 对应的 Release( ) 方法。

**面试官**：那这个方法谁来调用呢？

应聘者：可以在 main 函数里统一调用。

**面试官**：但是如果是基础代码库，实现 main 函数的工程师，并不知道他做的项目，需要依赖到多少个 singleton 对象相关的类啊，singleton class 实现者也不知道他的类会被多少人、多少项目使用到。

应聘者：说的也是。我再想想。可以搞个类似全局对象，让全局对象的析构函数来释放对应的内存。

**面试官**：是说一个singleton class 搞一个绑定的全局对象么？

应聘者：xxx

**面试官**：操作系统有没有提供类似的 API 呢，比如在 main 函数退出之前去释放一些对象的内存？

应聘者：不知道。**（这里可以考察 atexit 函数的意义，接口，然后由接口考察函数指针，functional, bind 等 C++ 知识）**

**面试官**：行，要不这个问题我们就面试到这里吧。你有兴趣的话，回去可以自己再思考下内存释放的相关方案。

应聘者：好的，谢谢。

  

**总结**

**![](https://mmbiz.qpic.cn/mmbiz_jpg/qX2ED6UwyKGBOMQWFvEBzaxWLlJcs8796Urqw8qFTOSGTzMSiaW09T9aJPMnNIWZXZNnFFCdgTDHlkqHsZDYqfQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)**

上面有关 singleton 这个设计模式，问了很多相关的问题。看起来是单一的设计模式问题，不过从此延伸出来的可以考察的知识点却可以有很多，下面随便举一些：

  

> -   C++ static 关键字
>     
> -   C++ private，public 关键字
>     
> -   C++ 对象内存模型
>     
> -   内存泄漏检测
>     
> -   内存管理经验
>     
> -   函数指针，仿函数等
>     
> -   智能指针，new，delete 的实现，new 与 malloc 的异同点
>     
> -   atexit 等
>     
> -   C 语言怎么实现类似单例的功能
>     
> -   C++ 的 RAII 理解程度
>     
> -   ELF 或者 PE 文件格式，static 等放在哪个 section 等
>     
> -   C++ 中对象和函数（行为和数据）怎么绑定
>     
> -   接口设计和调用约定等经验
>     
> -   常用的设计模式
>     
> -   四人帮《设计模式》等经典技术书籍
>     
> -   几个构造函数  
>     
> -   lazy 模式构造与程序启动就构造的区别
>     

  

有关 Singleton 设计模式的高阶问题，可以参考《[C++ Singleton 发展史 | 面向对象的世界里，写错单例模式，你并不孤单](http://mp.weixin.qq.com/s?__biz=MzI3NzE1NDcyNQ==&mid=2247484352&idx=1&sn=93183add638fa03a2c38b4ddf40671db&chksm=eb6bdd0adc1c541c523deb6ac54aca3c16f271d249c39aef1fc0d0b007a038ed0c7acb4e54e7&scene=21#wechat_redirect)》，看看大师们是怎么解决线程安全问题的，看看 C++11 新标准的到来，为简单的实现提供了什么新的可能性。

  

本文中**「应聘者：xxx」**有意省略掉一些回答的细节，方便大家做出自己的思考。文中很多应聘者的回答也是错误的，大家可以自己多思考，翻阅相关书籍，查阅相关论文，理清楚本文中面试官提出的各种问题，从而达到真正深刻掌握 C++ 语言，掌握好 Singleton 设计模式的目的。当然也**欢迎大家留言，说出你对本文中各种问题的答案，说出你遇到的有关 Singleton 设计模式的各种奇形怪状的问题，以及本文没有提及的各种奇葩错误回答。**对大家高频的疑惑，我们后续可以再专文分析解答。

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTQxNDMyODkyM119
-->